<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚¸ã‚§ãƒƒãƒˆã‚³ãƒ¼ã‚¹ã‚¿ãƒ¼ãƒ»ãƒ“ãƒ«ãƒ€ãƒ¼</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'sans-serif';
        }

        canvas {
            display: block;
        }

        .ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            pointer-events: none;
        }

        .ui-overlay>* {
            pointer-events: auto;
        }

        .instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            pointer-events: none;
        }
    </style>
</head>

<body>

    <div class="ui-overlay space-y-4">
        <div class="bg-white/90 p-4 rounded-2xl shadow-xl border-2 border-blue-400 w-64">
            <h1 class="text-xl font-bold text-blue-800 mb-2">ğŸ¢ ã‚³ãƒ¼ã‚¹å»ºè¨­</h1>

            <div class="mb-4">
                <label class="block text-sm font-bold text-gray-700">æ¬¡ã®ãƒã‚¤ãƒ³ãƒˆã®é«˜ã•</label>
                <input type="range" id="height-slider" min="0" max="100" value="20"
                    class="w-full h-2 bg-blue-200 rounded-lg appearance-none cursor-pointer">
                <div class="flex justify-between text-xs text-gray-500">
                    <span>ä½ã„</span>
                    <span>é«˜ã„</span>
                </div>
            </div>

            <div class="flex flex-col gap-2">
                <button id="btn-play"
                    class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-xl shadow-md transition-colors flex items-center justify-center gap-2">
                    <span>ğŸš€</span> è©¦ä¹—ã‚¹ã‚¿ãƒ¼ãƒˆ
                </button>
                <button id="btn-clear"
                    class="bg-red-400 hover:bg-red-500 text-white font-bold py-2 px-4 rounded-xl shadow-md transition-colors flex items-center justify-center gap-2">
                    <span>ğŸ—‘ï¸</span> ãƒªã‚»ãƒƒãƒˆ
                </button>
            </div>
        </div>

        <div id="stats" class="bg-black/50 text-white p-3 rounded-xl text-sm hidden">
            èµ°è¡Œé€Ÿåº¦: <span id="speed-val">0</span> km/h
        </div>
    </div>

    <div class="instructions" id="instruction-text">
        åœ°é¢ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ã‚¹ã®ãƒã‚¤ãƒ³ãƒˆã‚’è¨­ç½®ã—ã¦ãã ã•ã„
    </div>

    <script>
        let scene, camera, renderer, clock;
        let points = [];
        let trackMesh, trackLine, supportGroup;
        let coasterCar;
        let isPlaying = false;
        let progress = 0;
        let curve = null;

        // UIè¦ç´ 
        const heightSlider = document.getElementById('height-slider');
        const btnPlay = document.getElementById('btn-play');
        const btnClear = document.getElementById('btn-clear');
        const instructionText = document.getElementById('instruction-text');
        const stats = document.getElementById('stats');
        const speedVal = document.getElementById('speed-val');

        init();
        animate();

        function init() {
            // ã‚·ãƒ¼ãƒ³è¨­å®š
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb); // Sky Blue
            scene.fog = new THREE.Fog(0x87ceeb, 50, 500);

            // ã‚«ãƒ¡ãƒ©
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(100, 80, 100);
            camera.lookAt(0, 0, 0);

            // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // ãƒ©ã‚¤ãƒˆ
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
            sunLight.position.set(50, 100, 50);
            sunLight.castShadow = true;
            scene.add(sunLight);

            // åœ°é¢
            const grid = new THREE.GridHelper(1000, 50, 0x44aa44, 0x88cc88);
            scene.add(grid);

            const groundGeo = new THREE.PlaneGeometry(1000, 1000);
            const groundMat = new THREE.MeshPhongMaterial({ color: 0x7cfc00 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.1;
            ground.receiveShadow = true;
            scene.add(ground);

            // ã‚³ãƒ¼ã‚¹ãƒ»ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨
            supportGroup = new THREE.Group();
            scene.add(supportGroup);

            // è»Šä½“
            const carGeo = new THREE.BoxGeometry(2, 1, 4);
            const carMat = new THREE.MeshPhongMaterial({ color: 0xff0000 });
            coasterCar = new THREE.Mesh(carGeo, carMat);
            coasterCar.castShadow = true;
            coasterCar.visible = false;
            scene.add(coasterCar);

            clock = new THREE.Clock();

            // ã‚¤ãƒ™ãƒ³ãƒˆ
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('mousedown', onMouseDown);

            btnPlay.addEventListener('click', togglePlay);
            btnClear.addEventListener('click', clearTrack);
        }

        function onMouseDown(event) {
            if (isPlaying) return;

            // ãƒã‚¦ã‚¹åº§æ¨™ã‹ã‚‰3Dç©ºé–“ã®åœ°é¢ä¸Šã®ç‚¹ã‚’è¨ˆç®—
            const mouse = new THREE.Vector2(
                (event.clientX / window.innerWidth) * 2 - 1,
                -(event.clientY / window.innerHeight) * 2 + 1
            );

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            // åœ°é¢ï¼ˆy=0ã®å¹³é¢ï¼‰ã¨ã®äº¤ç‚¹ã‚’å–å¾—
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const intersectPoint = new THREE.Vector3();
            if (raycaster.ray.intersectPlane(plane, intersectPoint)) {
                const h = parseFloat(heightSlider.value);
                const newPoint = new THREE.Vector3(intersectPoint.x, h, intersectPoint.z);
                points.push(newPoint);
                updateTrack();
                createSparkle(event.clientX, event.clientY);
            }
        }

        function updateTrack() {
            // å¤ã„ã‚³ãƒ¼ã‚¹ã‚’å‰Šé™¤
            if (trackMesh) scene.remove(trackMesh);
            if (trackLine) scene.remove(trackLine);
            supportGroup.clear();

            if (points.length < 2) return;

            // æ›²ç·šã®ä½œæˆ
            curve = new THREE.CatmullRomCurve3(points);
            curve.curveType = 'centripetal';
            curve.closed = points.length > 3; // 4ç‚¹ä»¥ä¸Šã§é–‰ã˜ã‚‹

            // ã‚³ãƒ¼ã‚¹ã®å½¢çŠ¶ï¼ˆãƒãƒ¥ãƒ¼ãƒ–ï¼‰
            const tubeGeo = new THREE.TubeGeometry(curve, 100, 0.8, 8, curve.closed);
            const tubeMat = new THREE.MeshPhongMaterial({ color: 0x333333 });
            trackMesh = new THREE.Mesh(tubeGeo, tubeMat);
            trackMesh.castShadow = true;
            trackMesh.receiveShadow = true;
            scene.add(trackMesh);

            // æ”¯æŸ±ã®ä½œæˆ
            points.forEach(p => {
                const supportGeo = new THREE.CylinderGeometry(0.5, 0.5, p.y);
                const supportMat = new THREE.MeshPhongMaterial({ color: 0xaaaaaa });
                const support = new THREE.Mesh(supportGeo, supportMat);
                support.position.set(p.x, p.y / 2, p.z);
                supportGroup.add(support);
            });
        }

        function togglePlay() {
            if (points.length < 3) {
                alert("ã‚³ãƒ¼ã‚¹ã‚’å®Œæˆã•ã›ã‚‹ã«ã¯å°‘ãªãã¨ã‚‚3ã¤ä»¥ä¸Šã®ãƒã‚¤ãƒ³ãƒˆã‚’è¨­ç½®ã—ã¦ãã ã•ã„ï¼");
                return;
            }

            isPlaying = !isPlaying;

            if (isPlaying) {
                btnPlay.innerHTML = "<span>â¹ï¸</span> å»ºè¨­ã«æˆ»ã‚‹";
                instructionText.innerText = "èµ°è¡Œä¸­ï¼(ESCã§æˆ»ã‚‹)";
                coasterCar.visible = true;
                progress = 0;
                stats.classList.remove('hidden');
            } else {
                btnPlay.innerHTML = "<span>ğŸš€</span> è©¦ä¹—ã‚¹ã‚¿ãƒ¼ãƒˆ";
                instructionText.innerText = "åœ°é¢ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ã‚¹ã®ãƒã‚¤ãƒ³ãƒˆã‚’è¨­ç½®ã—ã¦ãã ã•ã„";
                coasterCar.visible = false;
                stats.classList.add('hidden');

                // ã‚«ãƒ¡ãƒ©ã‚’å…ƒã«æˆ»ã™
                camera.position.set(100, 80, 100);
                camera.lookAt(0, 0, 0);
            }
        }

        function clearTrack() {
            points = [];
            curve = null;
            isPlaying = false;
            updateTrack();
            coasterCar.visible = false;
            btnPlay.innerHTML = "<span>ğŸš€</span> è©¦ä¹—ã‚¹ã‚¿ãƒ¼ãƒˆ";
            stats.classList.add('hidden');
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            if (isPlaying && curve) {
                // é€²è¡Œé€Ÿåº¦ï¼ˆé«˜ã•ã«ã‚ˆã£ã¦å¤‰ãˆã‚‹æ“¬ä¼¼ç‰©ç†ï¼‰
                const currentPoint = curve.getPointAt(progress % 1);
                const nextProgress = (progress + 0.001) % 1;
                const nextPoint = curve.getPointAt(nextProgress);

                // é«˜ã•ã®å·®ã‚’åˆ©ç”¨ã—ãŸé€Ÿåº¦å¤‰åŒ–
                const drop = currentPoint.y - nextPoint.y;
                let speed = 0.05 + drop * 0.5;
                speed = Math.max(0.02, speed); // æœ€ä½é€Ÿåº¦

                progress += speed * delta;
                if (progress > 1) progress = 0;

                const pos = curve.getPointAt(progress % 1);
                const tangent = curve.getTangentAt(progress % 1).normalize();

                coasterCar.position.copy(pos);
                coasterCar.lookAt(pos.clone().add(tangent));

                // ä¸€äººç§°ã‚«ãƒ¡ãƒ©ã®è¨­å®š
                const camPos = pos.clone().add(new THREE.Vector3(0, 1.5, 0));
                camera.position.copy(camPos);
                camera.lookAt(pos.clone().add(tangent).add(new THREE.Vector3(0, 1.2, 0)));

                speedVal.innerText = Math.floor(speed * 2000);
            } else {
                // å»ºè¨­ãƒ¢ãƒ¼ãƒ‰ã§ã®ã‚«ãƒ¡ãƒ©å›è»¢ï¼ˆã‚†ã£ãã‚Šï¼‰
                const timer = Date.now() * 0.0001;
                camera.position.x = Math.cos(timer) * 150;
                camera.position.z = Math.sin(timer) * 150;
                camera.lookAt(0, 20, 0);
            }

            renderer.render(scene, camera);
        }

        function createSparkle(x, y) {
            const sparkle = document.createElement('div');
            sparkle.style.position = 'fixed';
            sparkle.style.left = x + 'px';
            sparkle.style.top = y + 'px';
            sparkle.style.pointerEvents = 'none';
            sparkle.innerHTML = 'âœ¨';
            sparkle.style.fontSize = '24px';
            sparkle.animate([
                { transform: 'translate(-50%, -50%) scale(0)', opacity: 1 },
                { transform: 'translate(-50%, -150%) scale(1.5)', opacity: 0 }
            ], { duration: 1000, easing: 'ease-out' });
            document.body.appendChild(sparkle);
            setTimeout(() => sparkle.remove(), 1000);
        }

        // ESCã‚­ãƒ¼ã§å»ºè¨­ãƒ¢ãƒ¼ãƒ‰ã«æˆ»ã‚‹
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && isPlaying) togglePlay();
        });
    </script>
</body>

</html>